{"version":3,"sources":["chartist-plugin-threshold.js"],"names":["root","factory","define","amd","returnExportsGlobal","exports","module","this","window","document","Chartist","createMasks","chart","threshold","options","defs","svg","querySelector","elem","width","height","aboveMask","x","y","id","maskNames","aboveThreshold","belowMask","belowThreshold","hasData","thresholdSvgPath","generateSvgPath","lineSmooth","firstElement","pathElements","lastElement","length","aboveMaskSvgPath","clone","position","remove","move","line","belowMaskSvgPath","d","stringify","fill","Threshold","value","normalize","defaultOptions","classNames","Interpolation","none","fillHoles","plugins","ctThreshold","extend","Line","Bar","on","data","series","name","type","thresholdValue","getThresholdValue","element","addClass","parent","_node","cloneNode","attr","mask","prototype","point","thresholdPoint","undefined","filter","tp","pop","index","getMultiValue","chartProperties","interpolator","pathCoordinates","pathData","forEach","valueIndex","p","chartRect","x1","axisX","projectValue","y1","axisY","push","isNum","constructor","points","Object","keys","map","count","reduce","prev","curr","Math","max","times","Array","Error","normalizedData","normalizeData","getDataArray","reverseData","shift"],"mappings":"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","file":"chartist-plugin-threshold.min.js","sourcesContent":["(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function () {\n      return (root.returnExportsGlobal = factory());\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like enviroments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    root['Chartist.plugins.ctThreshold'] = factory();\n  }\n}(this, function () {\n\n  /**\n   * Chartist.js plugin to display a data label on top of the points in a line chart.\n   *\n   */\n  /* global Chartist */\n  (function (window, document, Chartist) {\n    'use strict';\n\n    var defaultOptions = {\n      threshold: 0,\n      classNames: {\n        aboveThreshold: 'ct-threshold-above',\n        belowThreshold: 'ct-threshold-below'\n      },\n      maskNames: {\n        aboveThreshold: 'ct-threshold-mask-above',\n        belowThreshold: 'ct-threshold-mask-below'\n      },\n      lineSmooth: Chartist.Interpolation.none({\n        fillHoles: true\n      })\n    };\n\n    function createMasks(chart, threshold, options) {\n      // Select the defs element within the chart or create a new one\n      var defs = chart.svg.querySelector('defs') || chart.svg.elem('defs');\n      var width = chart.svg.width();\n      var height = chart.svg.height();\n\n      // Create mask for upper part above threshold\n      var aboveMask = defs\n        .elem('mask', {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height,\n          id: options.maskNames.aboveThreshold\n        });\n\n      // Create mask for lower part below threshold\n      var belowMask = defs\n        .elem('mask', {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height,\n          id: options.maskNames.belowThreshold\n        });\n\n      if (threshold.hasData()) {\n        // generate SVG path for the threshold series and append to each mask\n        var thresholdSvgPath = threshold.generateSvgPath(chart, options.lineSmooth);\n        var firstElement = thresholdSvgPath.pathElements[0];\n        var lastElement = thresholdSvgPath.pathElements[thresholdSvgPath.pathElements.length - 1];\n\n        // first element is removed and replaced with a line from top-left of the chart to the first point\n        var aboveMaskSvgPath = thresholdSvgPath.clone(true)\n          .position(0)\n          .remove(1)\n          .move(firstElement.x, 0)\n          .line(firstElement.x, firstElement.y)\n          .position(thresholdSvgPath.pathElements.length + 1)\n          .line(lastElement.x, 0);\n\n        // first element is removed and replaced with a line from bottom-left of the chart to the first point\n        var belowMaskSvgPath = thresholdSvgPath\n          .position(0)\n          .remove(1)\n          .move(firstElement.x, height)\n          .line(firstElement.x, firstElement.y)\n          .position(thresholdSvgPath.pathElements.length + 1)\n          .line(lastElement.x, height);\n\n        aboveMask.elem('path', {\n          d: aboveMaskSvgPath.stringify(),\n          fill: 'white'\n        });\n\n        belowMask.elem('path', {\n          d: belowMaskSvgPath.stringify(),\n          fill: 'white'\n        });\n      }\n\n      return defs;\n    }\n\n    Chartist.plugins = Chartist.plugins || {};\n    Chartist.plugins.ctThreshold = function (options) {\n\n      options = Chartist.extend({}, defaultOptions, options);\n\n      return function ctThreshold(chart) {\n        if (chart instanceof Chartist.Line || chart instanceof Chartist.Bar) {\n          var threshold = new Threshold(chart, options.threshold);\n\n          chart.on('draw', function (data) {\n            // if the element represents the control series, don't apply threshold classes or masks to it\n            if (data.series && data.series.name && data.series.name === threshold.value) {\n              return;\n            }\n\n            if (data.type === 'point') {\n              // For points we can just use the data value and compare against the threshold in order to determine\n              // the appropriate class\n\n              var thresholdValue = threshold.getThresholdValue(data);\n\n              data.element.addClass(\n                data.value.y >= thresholdValue ? options.classNames.aboveThreshold : options.classNames.belowThreshold\n              );\n            } else if (data.type === 'line' || data.type === 'bar' || data.type === 'area') {\n              // Cloning the original line path, mask it with the upper mask rect above the threshold and add the\n              // class for above threshold\n              data.element\n                .parent()\n                .elem(data.element._node.cloneNode(true))\n                .attr({\n                  mask: 'url(#' + options.maskNames.aboveThreshold + ')'\n                })\n                .addClass(options.classNames.aboveThreshold);\n\n              // Use the original line path, mask it with the lower mask rect below the threshold and add the class\n              // for blow threshold\n              data.element\n                .attr({\n                  mask: 'url(#' + options.maskNames.belowThreshold + ')'\n                })\n                .addClass(options.classNames.belowThreshold);\n            }\n          });\n\n          // On the created event, create the two mask definitions used to mask the line graphs\n          chart.on('created', function (data) {\n            if (threshold.hasData()) {\n              createMasks(data, threshold, options);\n            }\n          });\n        }\n      };\n    };\n\n    /**\n     * Constructor for Threshold class.\n     *\n     * @param {Chartist.Base} chart Chart instance\n     * @param {Number|String|Array|Object} value Threshold option passed in to Chartist.plugins.ctThreshold\n     * @constructor\n     */\n    function Threshold(chart, value) {\n      this.chart = chart;\n      this.value = value;\n      this.normalize(value);\n    };\n\n    /**\n     * Returns the threshold value corresponding to the provided point in a data series.\n     *\n     * @memberof Threshold\n     * @param {Object} A data point from a chart series\n     * @return {Number} Threshold value at given point\n     */\n    Threshold.prototype.getThresholdValue = function(point) {\n      var thresholdPoint;\n\n      if (point.value.x !== undefined) {\n        // for mult-dimensional points, find the point at x\n        thresholdPoint = this.series.data.filter(function(tp) {\n          return tp.x === point.value.x;\n        }).pop();\n      } else if (this.series.data[point.index]) {\n        // for plain arrays, use value at the series index\n        thresholdPoint = this.series.data[point.index];\n      }\n\n      return Chartist.getMultiValue(thresholdPoint, 'y');\n    };\n\n    /**\n     * Checks if the threshold instance contains any data.\n     *\n     * @memberof Threshold\n     * @return {Boolean} True if the threshold series contains any data, false otherwise\n     */\n    Threshold.prototype.hasData = function() {\n      return this.series && this.series.data.length > 0;\n    };\n\n    /**\n     * Generates and returns an SVG Path for the threshold data.\n     *\n     * @memberof Threshold\n     * @param {Object} chartProperties An object containing properties of the chart for which the path is being drawn\n     * @param {Function} interpolator Interpolation function to use when rendering the path\n     * @return {Chartist.Svg.Path} SVG path representing the threshold data\n     */\n    Threshold.prototype.generateSvgPath = function(chartProperties, interpolator) {\n      var pathCoordinates = [];\n      var pathData = [];\n      var data = this.series.data;\n\n      data.forEach(function(value, valueIndex) {\n        var p = {\n          x: chartProperties.chartRect.x1 + chartProperties.axisX.projectValue(value, valueIndex, data),\n          y: chartProperties.chartRect.y1 - chartProperties.axisY.projectValue(value, valueIndex, data)\n        };\n\n        pathCoordinates.push(p.x, p.y);\n        pathData.push({\n          value: value,\n          valueIndex: valueIndex\n        });\n      });\n\n      return interpolator(pathCoordinates, pathData);\n    };\n\n    /**\n     * Converts threshold value to a data series and normalizes the data.\n     *\n     * @memberof Threshold\n     * @param {Number|String|Array|Object} Value of the threshold option passed in to plugin\n     * @return {Threshold} Threshold instance\n     */\n    Threshold.prototype.normalize = function(value) {\n      this.series = null;\n\n      // if threshold is a static number, generate a series of static data points\n      if (Chartist.isNum(value)) {\n        var data = [];\n\n        if (this.chart.data.series.length) {\n          var axisX = this.chart.options.axisX;\n\n          // if using multi-dimensional points, we have to generate a point for each value of x\n          if (axisX.type && axisX.type.prototype.constructor.name != 'StepAxis') {\n            var points = {};\n\n            this.chart.data.series.forEach(function(series) {\n              (series.data || series).forEach(function(point) {\n                points[point.x] = true;\n              });\n            });\n\n            data = Object.keys(points).map(function(x) {\n              return {x: +x, y: value};\n            });\n          } else {\n            var count = this.chart.data.series.reduce(function(prev, curr) {\n              return Math.max(prev, (curr.data || curr).length);\n            }, 0);\n\n            data = Chartist.times(count).map(function() {\n              return value;\n            });\n          }\n        }\n\n        this.series = {\n          data: data,\n          name: '_threshold'\n        };\n      } else {\n        // if threshold is a string, map threshold to series data of matching name\n        if (typeof value === 'string') {\n          this.series = this.chart.data.series.reduce(function(prev, curr) {\n            return curr.name === value ? curr : prev;\n          }, value);\n        } else if (value.constructor === Array) {\n          this.series = {\n            data: value,\n            name: '_threshold'\n          };\n        }\n\n        // if threshold is not an array or valid series name, throw an exception\n        if (!(this.series instanceof Object) || !this.series.data) {\n          throw new Error('Invalid \\'threshold\\' value provided to chartist-plugin-threshold: ' + value);\n        }\n      }\n\n      var normalizedData = Chartist.normalizeData({\n        series: [this.series]\n      });\n\n      this.series.data = Chartist.getDataArray(normalizedData, this.chart.options.reverseData, true).shift();\n\n      return this;\n    };\n  }(window, document, Chartist));\n\n  return Chartist.plugins.ctThreshold;\n\n}));\n"]}